<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CpeMemoryIndex.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Dependency-Check Maven Plugin</a> &gt; <a href="../index.html" class="el_bundle">dependency-check-core</a> &gt; <a href="index.source.html" class="el_package">org.owasp.dependencycheck.data.cpe</a> &gt; <span class="el_source">CpeMemoryIndex.java</span></div><h1>CpeMemoryIndex.java</h1><pre class="source lang-java linenums">/*
 * This file is part of dependency-check-core.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (c) 2013 Jeremy Long. All Rights Reserved.
 */
package org.owasp.dependencycheck.data.cpe;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import javax.annotation.concurrent.ThreadSafe;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.core.KeywordAnalyzer;
import org.apache.lucene.analysis.miscellaneous.PerFieldAnalyzerWrapper;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.TextField;
import org.apache.lucene.index.CorruptIndexException;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.TopDocs;
import org.apache.lucene.store.RAMDirectory;
import org.owasp.dependencycheck.data.lucene.SearchFieldAnalyzer;
import org.owasp.dependencycheck.data.nvdcve.CveDB;
import org.owasp.dependencycheck.data.nvdcve.DatabaseException;
import org.owasp.dependencycheck.utils.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * &lt;p&gt;
 * An in memory Lucene index that contains the vendor/product combinations from
 * the CPE (application) identifiers within the NVD CVE data.&lt;/p&gt;
 *
 * This is the last remaining singleton in dependency-check-core; The use of
 * this singleton - while it may not technically be thread-safe (one database
 * used to build this index may not have the same entries as another) the risk
 * of this is currently believed to be small. As this memory index consumes a
 * large amount of memory we will remain using the singleton pattern for now.
 *
 * @author Jeremy Long
 */
@ThreadSafe
public final class CpeMemoryIndex implements AutoCloseable {

    /**
     * Singleton instance.
     */
<span class="fc" id="L69">    private static final CpeMemoryIndex INSTANCE = new CpeMemoryIndex();</span>
    /**
     * The logger.
     */
<span class="fc" id="L73">    private static final Logger LOGGER = LoggerFactory.getLogger(CpeMemoryIndex.class);</span>
    /**
     * The in memory Lucene index.
     */
    private RAMDirectory index;
    /**
     * The Lucene IndexReader.
     */
    private IndexReader indexReader;
    /**
     * The Lucene IndexSearcher.
     */
    private IndexSearcher indexSearcher;
    /**
     * The Lucene Analyzer used for Searching.
     */
    private Analyzer searchingAnalyzer;
    /**
     * The Lucene QueryParser used for Searching.
     */
    private QueryParser queryParser;
    /**
     * The product field analyzer.
     */
    private SearchFieldAnalyzer productFieldAnalyzer;
    /**
     * The vendor field analyzer.
     */
    private SearchFieldAnalyzer vendorFieldAnalyzer;
    /**
     * Track the number of current users of the Lucene index; used to track it
     * it is okay to actually close the index.
     */
<span class="fc" id="L106">    private final AtomicInteger usageCount = new AtomicInteger(0);</span>

    /**
     * private constructor for singleton.
     */
<span class="fc" id="L111">    private CpeMemoryIndex() {</span>
<span class="fc" id="L112">    }</span>

    /**
     * Gets the singleton instance of the CpeMemoryIndex.
     *
     * @return the instance of the CpeMemoryIndex
     */
    public static CpeMemoryIndex getInstance() {
<span class="fc" id="L120">        return INSTANCE;</span>
    }

    /**
     * Creates and loads data into an in memory index.
     *
     * @param cve the data source to retrieve the cpe data
     * @throws IndexException thrown if there is an error creating the index
     */
    public synchronized void open(CveDB cve) throws IndexException {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (INSTANCE.usageCount.addAndGet(1) == 1) {</span>
<span class="fc" id="L131">            index = new RAMDirectory();</span>
<span class="fc" id="L132">            buildIndex(cve);</span>
            try {
<span class="fc" id="L134">                indexReader = DirectoryReader.open(index);</span>
<span class="nc" id="L135">            } catch (IOException ex) {</span>
<span class="nc" id="L136">                throw new IndexException(ex);</span>
<span class="fc" id="L137">            }</span>
<span class="fc" id="L138">            indexSearcher = new IndexSearcher(indexReader);</span>
<span class="fc" id="L139">            searchingAnalyzer = createSearchingAnalyzer();</span>
<span class="fc" id="L140">            queryParser = new QueryParser(Fields.DOCUMENT_KEY, searchingAnalyzer);</span>
        }
<span class="fc" id="L142">    }</span>

    /**
     * returns whether or not the index is open.
     *
     * @return whether or not the index is open
     */
    public synchronized boolean isOpen() {
<span class="nc bnc" id="L150" title="All 2 branches missed.">        return INSTANCE.usageCount.get() &gt; 0;</span>
    }

    /**
     * Creates an Analyzer for searching the CPE Index.
     *
     * @return the CPE Analyzer.
     */
    private Analyzer createSearchingAnalyzer() {
<span class="fc" id="L159">        final Map&lt;String, Analyzer&gt; fieldAnalyzers = new HashMap&lt;&gt;();</span>
<span class="fc" id="L160">        fieldAnalyzers.put(Fields.DOCUMENT_KEY, new KeywordAnalyzer());</span>
<span class="fc" id="L161">        productFieldAnalyzer = new SearchFieldAnalyzer();</span>
<span class="fc" id="L162">        vendorFieldAnalyzer = new SearchFieldAnalyzer();</span>
<span class="fc" id="L163">        fieldAnalyzers.put(Fields.PRODUCT, productFieldAnalyzer);</span>
<span class="fc" id="L164">        fieldAnalyzers.put(Fields.VENDOR, vendorFieldAnalyzer);</span>

<span class="fc" id="L166">        return new PerFieldAnalyzerWrapper(new KeywordAnalyzer(), fieldAnalyzers);</span>
    }

    /**
     * Closes the CPE Index.
     */
    @Override
    public synchronized void close() {
<span class="fc" id="L174">        final int count = INSTANCE.usageCount.get() - 1;</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (count &lt;= 0) {</span>
<span class="fc" id="L176">            INSTANCE.usageCount.set(0);</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">            if (searchingAnalyzer != null) {</span>
<span class="fc" id="L178">                searchingAnalyzer.close();</span>
<span class="fc" id="L179">                searchingAnalyzer = null;</span>
            }
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">            if (indexReader != null) {</span>
                try {
<span class="fc" id="L183">                    indexReader.close();</span>
<span class="nc" id="L184">                } catch (IOException ex) {</span>
<span class="nc" id="L185">                    LOGGER.trace(&quot;&quot;, ex);</span>
<span class="fc" id="L186">                }</span>
<span class="fc" id="L187">                indexReader = null;</span>
            }
<span class="fc" id="L189">            queryParser = null;</span>
<span class="fc" id="L190">            indexSearcher = null;</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            if (index != null) {</span>
<span class="fc" id="L192">                index.close();</span>
<span class="fc" id="L193">                index = null;</span>
            }
        }
<span class="fc" id="L196">    }</span>

    /**
     * Builds the CPE Lucene Index based off of the data within the CveDB.
     *
     * @param cve the data base containing the CPE data
     * @throws IndexException thrown if there is an issue creating the index
     */
    private void buildIndex(CveDB cve) throws IndexException {
<span class="fc" id="L205">        try (Analyzer analyzer = createSearchingAnalyzer();</span>
<span class="fc" id="L206">                IndexWriter indexWriter = new IndexWriter(index, new IndexWriterConfig(analyzer))) {</span>
            // Tip: reuse the Document and Fields for performance...
            // See &quot;Re-use Document and Field instances&quot; from
            // http://wiki.apache.org/lucene-java/ImproveIndexingSpeed
<span class="fc" id="L210">            final Document doc = new Document();</span>
<span class="fc" id="L211">            final Field v = new TextField(Fields.VENDOR, Fields.VENDOR, Field.Store.YES);</span>
<span class="fc" id="L212">            final Field p = new TextField(Fields.PRODUCT, Fields.PRODUCT, Field.Store.YES);</span>
<span class="fc" id="L213">            doc.add(v);</span>
<span class="fc" id="L214">            doc.add(p);</span>

<span class="fc" id="L216">            final Set&lt;Pair&lt;String, String&gt;&gt; data = cve.getVendorProductList();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            for (Pair&lt;String, String&gt; pair : data) {</span>
<span class="pc bpc" id="L218" title="2 of 4 branches missed.">                if (pair.getLeft() != null &amp;&amp; pair.getRight() != null) {</span>
<span class="fc" id="L219">                    v.setStringValue(pair.getLeft());</span>
<span class="fc" id="L220">                    p.setStringValue(pair.getRight());</span>
<span class="fc" id="L221">                    indexWriter.addDocument(doc);</span>
<span class="fc" id="L222">                    productFieldAnalyzer.reset();</span>
<span class="fc" id="L223">                    vendorFieldAnalyzer.reset();</span>
                }
<span class="fc" id="L225">            }</span>
<span class="fc" id="L226">            indexWriter.commit();</span>
<span class="nc" id="L227">        } catch (DatabaseException ex) {</span>
<span class="nc" id="L228">            LOGGER.debug(&quot;&quot;, ex);</span>
<span class="nc" id="L229">            throw new IndexException(&quot;Error reading CPE data&quot;, ex);</span>
<span class="nc" id="L230">        } catch (IOException ex) {</span>
<span class="nc" id="L231">            throw new IndexException(&quot;Unable to close an in-memory index&quot;, ex);</span>
<span class="fc" id="L232">        }</span>
<span class="fc" id="L233">    }</span>

    /**
     * Searches the index using the given search string.
     *
     * @param searchString the query text
     * @param maxQueryResults the maximum number of documents to return
     * @return the TopDocs found by the search
     * @throws ParseException thrown when the searchString is invalid
     * @throws IOException is thrown if there is an issue with the underlying
     * Index
     */
    public synchronized TopDocs search(String searchString, int maxQueryResults) throws ParseException, IOException {
<span class="fc" id="L246">        final Query query = parseQuery(searchString);</span>
<span class="fc" id="L247">        productFieldAnalyzer.reset();</span>
<span class="fc" id="L248">        vendorFieldAnalyzer.reset();</span>
<span class="fc" id="L249">        return search(query, maxQueryResults);</span>
    }

    /**
     * Parses the given string into a Lucene Query.
     *
     * @param searchString the search text
     * @return the Query object
     * @throws ParseException thrown if the search text cannot be parsed
     */
    protected Query parseQuery(String searchString) throws ParseException {
<span class="pc bpc" id="L260" title="2 of 4 branches missed.">        if (searchString == null || searchString.trim().isEmpty()) {</span>
<span class="nc" id="L261">            throw new ParseException(&quot;Query is null or empty&quot;);</span>
        }
<span class="fc" id="L263">        LOGGER.debug(searchString);</span>
<span class="fc" id="L264">        final Query query = queryParser.parse(searchString);</span>
<span class="fc" id="L265">        return query;</span>
    }

    /**
     * Searches the index using the given query.
     *
     * @param query the query used to search the index
     * @param maxQueryResults the max number of results to return
     * @return the TopDocs found be the query
     * @throws CorruptIndexException thrown if the Index is corrupt
     * @throws IOException thrown if there is an IOException
     */
    public synchronized TopDocs search(Query query, int maxQueryResults) throws CorruptIndexException, IOException {
<span class="fc" id="L278">        return indexSearcher.search(query, maxQueryResults);</span>
    }

    /**
     * Retrieves a document from the Index.
     *
     * @param documentId the id of the document to retrieve
     * @return the Document
     * @throws IOException thrown if there is an IOException
     */
    public synchronized Document getDocument(int documentId) throws IOException {
<span class="fc" id="L289">        return indexSearcher.doc(documentId);</span>
    }

    /**
     * Returns the number of CPE entries stored in the index.
     *
     * @return the number of CPE entries stored in the index
     */
    public synchronized int numDocs() {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (indexReader == null) {</span>
<span class="nc" id="L299">            return -1;</span>
        }
<span class="nc" id="L301">        return indexReader.numDocs();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>