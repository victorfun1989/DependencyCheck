<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HintAnalyzer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Dependency-Check Maven Plugin</a> &gt; <a href="../index.html" class="el_bundle">dependency-check-core</a> &gt; <a href="index.source.html" class="el_package">org.owasp.dependencycheck.analyzer</a> &gt; <span class="el_source">HintAnalyzer.java</span></div><h1>HintAnalyzer.java</h1><pre class="source lang-java linenums">/*
 * This file is part of dependency-check-core.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (c) 2012 Jeremy Long. All Rights Reserved.
 */
package org.owasp.dependencycheck.analyzer;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import javax.annotation.concurrent.ThreadSafe;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.analyzer.exception.AnalysisException;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Evidence;
import org.owasp.dependencycheck.dependency.EvidenceType;
import org.owasp.dependencycheck.exception.InitializationException;
import org.owasp.dependencycheck.xml.suppression.PropertyType;
import org.owasp.dependencycheck.utils.DownloadFailedException;
import org.owasp.dependencycheck.utils.Downloader;
import org.owasp.dependencycheck.utils.FileUtils;
import org.owasp.dependencycheck.utils.Settings;
import org.owasp.dependencycheck.xml.hints.EvidenceMatcher;
import org.owasp.dependencycheck.xml.hints.VendorDuplicatingHintRule;
import org.owasp.dependencycheck.xml.hints.HintParseException;
import org.owasp.dependencycheck.xml.hints.HintParser;
import org.owasp.dependencycheck.xml.hints.HintRule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

/**
 * This analyzer adds evidence to dependencies to enhance the accuracy of
 * library identification.
 *
 * @author Jeremy Long
 */
@ThreadSafe
<span class="fc" id="L58">public class HintAnalyzer extends AbstractAnalyzer {</span>

    /**
     * The Logger for use throughout the class
     */
<span class="fc" id="L63">    private static final Logger LOGGER = LoggerFactory.getLogger(HintAnalyzer.class);</span>
    /**
     * The name of the hint rule file
     */
    private static final String HINT_RULE_FILE_NAME = &quot;dependencycheck-base-hint.xml&quot;;
    /**
     * The array of hint rules.
     */
<span class="fc" id="L71">    private HintRule[] hints = null;</span>
    /**
     * The array of vendor duplicating hint rules.
     */
    private VendorDuplicatingHintRule[] vendorHints;
    /**
     * The name of the analyzer.
     */
    private static final String ANALYZER_NAME = &quot;Hint Analyzer&quot;;
    /**
     * The phase that this analyzer is intended to run in.
     */
<span class="fc" id="L83">    private static final AnalysisPhase ANALYSIS_PHASE = AnalysisPhase.PRE_IDENTIFIER_ANALYSIS;</span>

    /**
     * Returns the name of the analyzer.
     *
     * @return the name of the analyzer.
     */
    @Override
    public String getName() {
<span class="fc" id="L92">        return ANALYZER_NAME;</span>
    }

    /**
     * Returns the phase that the analyzer is intended to run in.
     *
     * @return the phase that the analyzer is intended to run in.
     */
    @Override
    public AnalysisPhase getAnalysisPhase() {
<span class="fc" id="L102">        return ANALYSIS_PHASE;</span>
    }

    /**
     * &lt;p&gt;
     * Returns the setting key to determine if the analyzer is enabled.&lt;/p&gt;
     *
     * @return the key for the analyzer's enabled property
     */
    @Override
    protected String getAnalyzerEnabledSettingKey() {
<span class="fc" id="L113">        return Settings.KEYS.ANALYZER_HINT_ENABLED;</span>
    }

    /**
     * The prepare method does nothing for this Analyzer.
     *
     * @param engine a reference the dependency-check engine
     * @throws InitializationException thrown if there is an exception
     */
    @Override
    public void prepareAnalyzer(Engine engine) throws InitializationException {
        try {
<span class="fc" id="L125">            loadHintRules();</span>
<span class="nc" id="L126">        } catch (HintParseException ex) {</span>
<span class="nc" id="L127">            LOGGER.debug(&quot;Unable to parse hint file&quot;, ex);</span>
<span class="nc" id="L128">            throw new InitializationException(&quot;Unable to parse the hint file&quot;, ex);</span>
<span class="fc" id="L129">        }</span>
<span class="fc" id="L130">    }</span>

    /**
     * The HintAnalyzer uses knowledge about a dependency to add additional
     * information to help in identification of identifiers or vulnerabilities.
     *
     * @param dependency The dependency being analyzed
     * @param engine The scanning engine
     * @throws AnalysisException is thrown if there is an exception analyzing
     * the dependency.
     */
    @Override
    protected void analyzeDependency(Dependency dependency, Engine engine) throws AnalysisException {
<span class="fc bfc" id="L143" title="All 2 branches covered.">        for (HintRule hint : hints) {</span>
<span class="fc" id="L144">            boolean matchFound = false;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">            for (EvidenceMatcher given : hint.getGivenVendor()) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">                if (hasMatchingEvidence(dependency.getEvidence(EvidenceType.VENDOR), given)) {</span>
<span class="fc" id="L147">                    matchFound = true;</span>
<span class="fc" id="L148">                    break;</span>
                }
<span class="fc" id="L150">            }</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            if (!matchFound) {</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">                for (EvidenceMatcher given : hint.getGivenProduct()) {</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">                    if (hasMatchingEvidence(dependency.getEvidence(EvidenceType.PRODUCT), given)) {</span>
<span class="fc" id="L154">                        matchFound = true;</span>
<span class="fc" id="L155">                        break;</span>
                    }
<span class="fc" id="L157">                }</span>
            }
<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (!matchFound) {</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">                for (EvidenceMatcher given : hint.getGivenVersion()) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                    if (hasMatchingEvidence(dependency.getEvidence(EvidenceType.VERSION), given)) {</span>
<span class="nc" id="L162">                        matchFound = true;</span>
<span class="nc" id="L163">                        break;</span>
                    }
<span class="nc" id="L165">                }</span>
            }
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (!matchFound) {</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">                for (PropertyType pt : hint.getFilenames()) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                    if (pt.matches(dependency.getFileName())) {</span>
<span class="fc" id="L170">                        matchFound = true;</span>
<span class="fc" id="L171">                        break;</span>
                    }
<span class="fc" id="L173">                }</span>
            }
<span class="fc bfc" id="L175" title="All 2 branches covered.">            if (matchFound) {</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                for (Evidence e : hint.getAddVendor()) {</span>
<span class="fc" id="L177">                    dependency.addEvidence(EvidenceType.VENDOR, e);</span>
<span class="fc" id="L178">                }</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">                for (Evidence e : hint.getAddProduct()) {</span>
<span class="fc" id="L180">                    dependency.addEvidence(EvidenceType.PRODUCT, e);</span>
<span class="fc" id="L181">                }</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">                for (Evidence e : hint.getAddVersion()) {</span>
<span class="nc" id="L183">                    dependency.addEvidence(EvidenceType.VERSION, e);</span>
<span class="nc" id="L184">                }</span>

<span class="pc bpc" id="L186" title="1 of 2 branches missed.">                for (EvidenceMatcher e : hint.getRemoveVendor()) {</span>
<span class="nc" id="L187">                    removeMatchingEvidences(dependency, EvidenceType.VENDOR, e);</span>
<span class="nc" id="L188">                }</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">                for (EvidenceMatcher e : hint.getRemoveProduct()) {</span>
<span class="nc" id="L190">                    removeMatchingEvidences(dependency, EvidenceType.PRODUCT, e);</span>
<span class="nc" id="L191">                }</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                for (EvidenceMatcher e : hint.getRemoveVersion()) {</span>
<span class="nc" id="L193">                    removeMatchingEvidences(dependency, EvidenceType.VERSION, e);</span>
<span class="nc" id="L194">                }</span>
            }
        }

<span class="fc" id="L198">        final Iterator&lt;Evidence&gt; itr = dependency.getEvidence(EvidenceType.VENDOR).iterator();</span>
<span class="fc" id="L199">        final List&lt;Evidence&gt; newEntries = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        while (itr.hasNext()) {</span>
<span class="fc" id="L201">            final Evidence e = itr.next();</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            for (VendorDuplicatingHintRule dhr : vendorHints) {</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">                if (dhr.getValue().equalsIgnoreCase(e.getValue())) {</span>
<span class="fc" id="L204">                    newEntries.add(new Evidence(e.getSource() + &quot; (hint)&quot;,</span>
<span class="fc" id="L205">                            e.getName(), dhr.getDuplicate(), e.getConfidence()));</span>
                }
            }
<span class="fc" id="L208">        }</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (Evidence e : newEntries) {</span>
<span class="fc" id="L210">            dependency.addEvidence(EvidenceType.VENDOR, e);</span>
<span class="fc" id="L211">        }</span>
<span class="fc" id="L212">    }</span>

    /**
     * Determine if there is matching evidence.
     *
     * @param evidences the evidence to test
     * @param criterion the criteria for a match
     * @return true if the evidence matches, otherwise false
     */
    private boolean hasMatchingEvidence(Set&lt;Evidence&gt; evidences, EvidenceMatcher criterion) {
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (Evidence evidence : evidences) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (criterion.matches(evidence)) {</span>
<span class="fc" id="L224">                return true;</span>
            }
<span class="fc" id="L226">        }</span>
<span class="fc" id="L227">        return false;</span>
    }

    /**
     * Removes any matching evidence from the dependency.
     *
     * @param dependency the dependency to update
     * @param type the type of evidence to inspect and possibly remove
     * @param e the evidence matcher
     */
    private void removeMatchingEvidences(Dependency dependency, EvidenceType type, EvidenceMatcher e) {
<span class="nc bnc" id="L238" title="All 2 branches missed.">        for (Evidence evidence : dependency.getEvidence(type)) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (e.matches(evidence)) {</span>
<span class="nc" id="L240">                dependency.removeEvidence(type, evidence);</span>
            }
<span class="nc" id="L242">        }</span>
<span class="nc" id="L243">    }</span>

    /**
     * Loads the hint rules file.
     *
     * @throws HintParseException thrown if the XML cannot be parsed.
     */
    private void loadHintRules() throws HintParseException {
        final List&lt;HintRule&gt; localHints;
        final List&lt;VendorDuplicatingHintRule&gt; localVendorHints;
<span class="fc" id="L253">        final HintParser parser = new HintParser();</span>
<span class="fc" id="L254">        File file = null;</span>
        try {
<span class="fc" id="L256">            parser.parseHints(FileUtils.getResourceAsStream(HINT_RULE_FILE_NAME));</span>
<span class="nc" id="L257">        } catch (SAXException ex) {</span>
<span class="nc" id="L258">            throw new HintParseException(&quot;Error parsing hinits: &quot; + ex.getMessage(), ex);</span>
<span class="fc" id="L259">        }</span>
<span class="fc" id="L260">        localHints = parser.getHintRules();</span>
<span class="fc" id="L261">        localVendorHints = parser.getVendorDuplicatingHintRules();</span>

<span class="fc" id="L263">        final String filePath = getSettings().getString(Settings.KEYS.HINTS_FILE);</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (filePath != null) {</span>
<span class="nc" id="L265">            boolean deleteTempFile = false;</span>
            try {
<span class="nc" id="L267">                final Pattern uriRx = Pattern.compile(&quot;^(https?|file)\\:.*&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">                if (uriRx.matcher(filePath).matches()) {</span>
<span class="nc" id="L269">                    deleteTempFile = true;</span>
<span class="nc" id="L270">                    file = getSettings().getTempFile(&quot;hint&quot;, &quot;xml&quot;);</span>
<span class="nc" id="L271">                    final URL url = new URL(filePath);</span>
<span class="nc" id="L272">                    final Downloader downloader = new Downloader(getSettings());</span>
                    try {
<span class="nc" id="L274">                        downloader.fetchFile(url, file, false);</span>
<span class="nc" id="L275">                    } catch (DownloadFailedException ex) {</span>
<span class="nc" id="L276">                        downloader.fetchFile(url, file, true);</span>
<span class="nc" id="L277">                    }</span>
<span class="nc" id="L278">                } else {</span>
<span class="nc" id="L279">                    file = new File(filePath);</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                    if (!file.exists()) {</span>
<span class="nc" id="L281">                        try (InputStream fromClasspath = FileUtils.getResourceAsStream(filePath)) {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                            if (fromClasspath != null) {</span>
<span class="nc" id="L283">                                deleteTempFile = true;</span>
<span class="nc" id="L284">                                file = getSettings().getTempFile(&quot;hint&quot;, &quot;xml&quot;);</span>
                                try {
<span class="nc" id="L286">                                    org.apache.commons.io.FileUtils.copyInputStreamToFile(fromClasspath, file);</span>
<span class="nc" id="L287">                                } catch (IOException ex) {</span>
<span class="nc" id="L288">                                    throw new HintParseException(&quot;Unable to locate hints file in classpath&quot;, ex);</span>
<span class="nc" id="L289">                                }</span>
                            }
                        }
                    }
                }

<span class="nc bnc" id="L295" title="All 2 branches missed.">                if (file != null) {</span>
                    try {
<span class="nc" id="L297">                        parser.parseHints(file);</span>
<span class="nc bnc" id="L298" title="All 4 branches missed.">                        if (parser.getHintRules() != null &amp;&amp; !parser.getHintRules().isEmpty()) {</span>
<span class="nc" id="L299">                            localHints.addAll(parser.getHintRules());</span>
                        }
<span class="nc bnc" id="L301" title="All 4 branches missed.">                        if (parser.getVendorDuplicatingHintRules() != null &amp;&amp; !parser.getVendorDuplicatingHintRules().isEmpty()) {</span>
<span class="nc" id="L302">                            localVendorHints.addAll(parser.getVendorDuplicatingHintRules());</span>
                        }
<span class="nc" id="L304">                    } catch (HintParseException ex) {</span>
<span class="nc" id="L305">                        LOGGER.warn(&quot;Unable to parse hint rule xml file '{}'&quot;, file.getPath());</span>
<span class="nc" id="L306">                        LOGGER.warn(ex.getMessage());</span>
<span class="nc" id="L307">                        LOGGER.debug(&quot;&quot;, ex);</span>
<span class="nc" id="L308">                        throw ex;</span>
<span class="nc" id="L309">                    }</span>
                }
<span class="nc" id="L311">            } catch (DownloadFailedException ex) {</span>
<span class="nc" id="L312">                throw new HintParseException(&quot;Unable to fetch the configured hint file&quot;, ex);</span>
<span class="nc" id="L313">            } catch (MalformedURLException ex) {</span>
<span class="nc" id="L314">                throw new HintParseException(&quot;Configured hint file has an invalid URL&quot;, ex);</span>
<span class="nc" id="L315">            } catch (IOException ex) {</span>
<span class="nc" id="L316">                throw new HintParseException(&quot;Unable to create temp file for hints&quot;, ex);</span>
            } finally {
<span class="nc bnc" id="L318" title="All 4 branches missed.">                if (deleteTempFile &amp;&amp; file != null) {</span>
<span class="nc" id="L319">                    FileUtils.delete(file);</span>
                }
            }
        }
<span class="fc" id="L323">        hints = localHints.toArray(new HintRule[localHints.size()]);</span>
<span class="fc" id="L324">        vendorHints = localVendorHints.toArray(new VendorDuplicatingHintRule[localVendorHints.size()]);</span>
<span class="fc" id="L325">        LOGGER.debug(&quot;{} hint rules were loaded.&quot;, hints.length);</span>
<span class="fc" id="L326">        LOGGER.debug(&quot;{} duplicating hint rules were loaded.&quot;, vendorHints.length);</span>
<span class="fc" id="L327">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>